/*! For license information please see createVerticesFromGoogleEarthEnterpriseBuffer.js.LICENSE.txt */
import{a as Gt,b as Xt}from"./chunk-YP3UZ353.js";import{a as kt}from"./chunk-54KKWN6C.js";import{a as lt}from"./chunk-TDXQUZ7V.js";import{a as Dt}from"./chunk-3M3462KZ.js";import"./chunk-TBE3AFZU.js";import"./chunk-ZI3LUCJT.js";import{a as qt}from"./chunk-WEOEL435.js";import"./chunk-UNOEZU66.js";import"./chunk-7AJQ7HJO.js";import{d as zt,i as Lt}from"./chunk-HXYTWA7P.js";import"./chunk-AT27Z3WO.js";import{b as $,c as Ot}from"./chunk-HB5KYIAZ.js";import"./chunk-JJLMPDRL.js";import{a as P,b as N,c as wt,d as Ht}from"./chunk-T4TQMW7B.js";import{a as r}from"./chunk-7TT2TZHW.js";import"./chunk-FRKPHPJC.js";import{a as Vt}from"./chunk-OHNTPGT4.js";import{a as Ut}from"./chunk-XQTMMRVI.js";import"./chunk-QHDGFGBI.js";import{e as ht}from"./chunk-MVZBAA6W.js";var te=Uint16Array.BYTES_PER_ELEMENT,mt=Int32Array.BYTES_PER_ELEMENT,Pt=Uint32Array.BYTES_PER_ELEMENT,ee=Float32Array.BYTES_PER_ELEMENT,H=Float64Array.BYTES_PER_ELEMENT;function tt(t,e,n){n=Ut(n,r);let i=t.length;for(let o=0;o<i;++o)if(n.equalsEpsilon(t[o],e,r.EPSILON12))return o;return-1}function oe(t,e){t.ellipsoid=Ht.clone(t.ellipsoid),t.rectangle=Ot.clone(t.rectangle);let n=se(t.buffer,t.relativeToCenter,t.ellipsoid,t.rectangle,t.nativeRectangle,t.exaggeration,t.exaggerationRelativeHeight,t.skirtHeight,t.includeWebMercatorT,t.negativeAltitudeExponentBias,t.negativeElevationThreshold),i=n.vertices;e.push(i.buffer);let r=n.indices;return e.push(r.buffer),{vertices:i.buffer,indices:r.buffer,numberOfAttributes:n.encoding.stride,minimumHeight:n.minimumHeight,maximumHeight:n.maximumHeight,boundingSphere3D:n.boundingSphere3D,orientedBoundingBox:n.orientedBoundingBox,occludeePointInScaledSpace:n.occludeePointInScaledSpace,encoding:n.encoding,vertexCountWithoutSkirts:n.vertexCountWithoutSkirts,indexCountWithoutSkirts:n.indexCountWithoutSkirts,westIndicesSouthToNorth:n.westIndicesSouthToNorth,southIndicesEastToWest:n.southIndicesEastToWest,eastIndicesNorthToSouth:n.eastIndicesNorthToSouth,northIndicesWestToEast:n.northIndicesWestToEast}}var u=new N,G=new P,ne=new P,ie=new P,re=new $;function se(t,e,n,i,o,a,s,l,h,c,m){let d,g,p,I,T,f;ht(i)?(d=i.west,g=i.south,p=i.east,I=i.north,T=i.width,f=i.height):(d=r.toRadians(o.west),g=r.toRadians(o.south),p=r.toRadians(o.east),I=r.toRadians(o.north),T=r.toRadians(i.width),f=r.toRadians(i.height));let E,x,w=[g,I],A=[d,p],S=Lt.eastNorthUpToFixedFrame(e,n),k=$.inverseTransformation(S,re);h&&(E=lt.geodeticLatitudeToMercatorAngle(g),x=1/(lt.geodeticLatitudeToMercatorAngle(I)-E));let b=1!==a,M=new DataView(t),B=Number.POSITIVE_INFINITY,R=Number.NEGATIVE_INFINITY,y=ne;y.x=Number.POSITIVE_INFINITY,y.y=Number.POSITIVE_INFINITY,y.z=Number.POSITIVE_INFINITY;let v=ie;v.x=Number.NEGATIVE_INFINITY,v.y=Number.NEGATIVE_INFINITY,v.z=Number.NEGATIVE_INFINITY;let F,W,_=0,j=0,U=0;for(W=0;W<4;++W){let t=_;F=M.getUint32(t,!0),t+=Pt;let e=r.toRadians(180*M.getFloat64(t,!0));t+=H,-1===tt(A,e)&&A.push(e);let n=r.toRadians(180*M.getFloat64(t,!0));t+=H,-1===tt(w,n)&&w.push(n),t+=2*H;let i=M.getInt32(t,!0);t+=mt,j+=i,i=M.getInt32(t,!0),U+=3*i,_+=F+Pt}let C=[],O=[],V=new Array(j),Y=new Array(j),L=new Array(j),Z=h?new Array(j):[],D=b?new Array(j):[],J=new Array(U),z=[],K=[],Q=[],X=[],q=0,et=0;for(_=0,W=0;W<4;++W){F=M.getUint32(_,!0),_+=Pt;let t=_,e=r.toRadians(180*M.getFloat64(_,!0));_+=H;let i=r.toRadians(180*M.getFloat64(_,!0));_+=H;let o=r.toRadians(180*M.getFloat64(_,!0)),a=.5*o;_+=H;let s=r.toRadians(180*M.getFloat64(_,!0)),l=.5*s;_+=H;let T=M.getInt32(_,!0);_+=mt;let f=M.getInt32(_,!0);_+=mt,_+=mt;let S=new Array(T);for(let H=0;H<T;++H){let t=e+M.getUint8(_++)*o;u.longitude=t;let T=i+M.getUint8(_++)*s;u.latitude=T;let f=M.getFloat32(_,!0);if(_+=ee,0!==f&&f<m&&(f*=-Math.pow(2,c)),f*=6371010,u.height=f,-1!==tt(A,t)||-1!==tt(w,T)){let t=tt(C,u,N);if(-1!==t){S[H]=O[t];continue}C.push(N.clone(u)),O.push(q)}S[H]=q,Math.abs(t-d)<a?z.push({index:q,cartographic:N.clone(u)}):Math.abs(t-p)<a?Q.push({index:q,cartographic:N.clone(u)}):Math.abs(T-g)<l?K.push({index:q,cartographic:N.clone(u)}):Math.abs(T-I)<l&&X.push({index:q,cartographic:N.clone(u)}),B=Math.min(f,B),R=Math.max(f,R),L[q]=f;let F=n.cartographicToCartesian(u);if(V[q]=F,h&&(Z[q]=(lt.geodeticLatitudeToMercatorAngle(T)-E)*x),b){let t=n.geodeticSurfaceNormal(F);D[q]=t}$.multiplyByPoint(k,F,G),P.minimumByComponent(G,y,y),P.maximumByComponent(G,v,v);let W=(t-d)/(p-d);W=r.clamp(W,0,1);let j=(T-g)/(I-g);j=r.clamp(j,0,1),Y[q]=new wt(W,j),++q}let W=3*f;for(let n=0;n<W;++n,++et)J[et]=S[M.getUint16(_,!0)],_+=te;if(F!==_-t)throw new Vt("Invalid terrain tile.")}V.length=q,Y.length=q,L.length=q,h&&(Z.length=q),b&&(D.length=q);let nt=q,it=et,rt={hMin:B,lastBorderPoint:void 0,skirtHeight:l,toENU:k,ellipsoid:n,minimum:y,maximum:v};z.sort((function(t,e){return e.cartographic.latitude-t.cartographic.latitude})),K.sort((function(t,e){return t.cartographic.longitude-e.cartographic.longitude})),Q.sort((function(t,e){return t.cartographic.latitude-e.cartographic.latitude})),X.sort((function(t,e){return e.cartographic.longitude-t.cartographic.longitude}));let ot=1e-5;if(gt(V,L,Y,Z,D,J,rt,z,-ot*T,!0,-ot*f),gt(V,L,Y,Z,D,J,rt,K,-ot*f,!1),gt(V,L,Y,Z,D,J,rt,Q,ot*T,!0,ot*f),gt(V,L,Y,Z,D,J,rt,X,ot*f,!1),z.length>0&&X.length>0){let t=z[0].index,e=nt,n=X[X.length-1].index,i=V.length-1;J.push(n,i,e,e,t,n)}j=V.length;let at,ut=zt.fromPoints(V);ht(i)&&(at=Dt.fromRectangle(i,B,R,n));let st=new Gt(n).computeHorizonCullingPointPossiblyUnderEllipsoid(e,V,B),ct=new qt(y,v,e),dt=new Xt(e,ct,rt.hMin,R,S,!1,h,b,a,s),pt=new Float32Array(j*dt.stride),It=0;for(let r=0;r<j;++r)It=dt.encode(pt,It,V[r],Y[r],L[r],void 0,Z[r],D[r]);let Tt=z.map((function(t){return t.index})).reverse(),ft=K.map((function(t){return t.index})).reverse(),Et=Q.map((function(t){return t.index})).reverse(),Nt=X.map((function(t){return t.index})).reverse();return ft.unshift(Et[Et.length-1]),ft.push(Tt[0]),Nt.unshift(Tt[Tt.length-1]),Nt.push(Et[0]),{vertices:pt,indices:new Uint16Array(J),maximumHeight:R,minimumHeight:B,encoding:dt,boundingSphere3D:ut,orientedBoundingBox:at,occludeePointInScaledSpace:st,vertexCountWithoutSkirts:nt,indexCountWithoutSkirts:it,westIndicesSouthToNorth:Tt,southIndicesEastToWest:ft,eastIndicesNorthToSouth:Et,northIndicesWestToEast:Nt}}function gt(t,e,n,i,o,a,s,l,h,c,m){let d=l.length;for(let g=0;g<d;++g){let p=l[g],I=p.cartographic,T=p.index,f=t.length,E=I.longitude,x=I.latitude;x=r.clamp(x,-r.PI_OVER_TWO,r.PI_OVER_TWO);let w=I.height-s.skirtHeight;s.hMin=Math.min(s.hMin,w),N.fromRadians(E,x,w,u),c&&(u.longitude+=h),c?g===d-1?u.latitude+=m:0===g&&(u.latitude-=m):u.latitude+=h;let A=s.ellipsoid.cartographicToCartesian(u);t.push(A),e.push(w),n.push(wt.clone(n[T])),i.length>0&&i.push(i[T]),o.length>0&&o.push(o[T]),$.multiplyByPoint(s.toENU,A,G);let S=s.minimum,k=s.maximum;P.minimumByComponent(G,S,S),P.maximumByComponent(G,k,k);let H=s.lastBorderPoint;if(ht(H)){let t=H.index;a.push(t,f-1,f,f,T,t)}s.lastBorderPoint=p}}var Ae=kt(oe);export{Ae as default};